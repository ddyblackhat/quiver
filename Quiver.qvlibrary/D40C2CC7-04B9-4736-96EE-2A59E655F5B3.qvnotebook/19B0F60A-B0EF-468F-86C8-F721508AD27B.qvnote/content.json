{
  "title": "Java并发(一)",
  "cells": [
    {
      "type": "text",
      "data": "<h2>1.1 线程安全</h2><div>当多个线程去访问一个类(对象或者方法)时，这个类始终都能表现出正确的行为，那么这个类（对象和方法）就是线程安全的。</div><h3>1.2 synchronized</h3><div>可以在任意方法和对象上加锁，而加锁的这段代码被称为’临界区’或者’互斥区’</div><div>①当多个线程去访问一个对象的run方法时，按照排队（这里排队是指CPU的分配顺序）的方式去执行synchronized修饰的方法，先去获得锁，然后执行里边的内容。这里会有锁竞争的问题，当线程太多时竞争一把锁容易造成CPU使用率过高或者宕机。</div><div>②synchronized取得的锁都是对象锁，不是synchronized修改的方法，当前线程获取的是syn修饰的方法所属对象的锁，两个对象是两把锁，互补干涉。</div><div>注：可以加static修改，static 表示当前.class类 ， 类级别的锁（<b>独占锁</b>）</div><h3>1.3 对象锁的同步和异步</h3><div>同步：synchronized &nbsp;&nbsp;</div><div>&nbsp; 同步的概念就是<b>共享</b>，如果不是共享就没必要同步</div><div>异步：asynchronized &nbsp;</div><div>&nbsp; 异步的概念就是独立，相互不受制约。</div><div>同步的目的就是为了线程安全，对于线程安全来说，需要满足两个特性:</div><div>&nbsp;<b> 原子性（同步）<br></b><b>&nbsp; 可见性</b></div><h3>1.4 volitile 关键字</h3><div>volitile关键字的主要作用就是使变量在多个线程中可见，不能保证原子性。</div><div>在Java中，每一个线程都会有一块工作内存去，其中存放着所有线程共享的主内存中的变量值得拷贝。为了存取一个共享的变量，一个线程通常先获取锁定并去清除它的工作区，把共享变量从所有线程的共享内存中区中正确的装入到他自己所在的工作内存区中，当线程解锁是保证该工作区中变量的值写回到共享内存中。</div><div>&nbsp; 一个线程可以执行的操作有使用 use、赋值 assign、装载load、存储store、lock、unlock</div><div>&nbsp; 而主内存可以执行的操作有read、write、lock、unlock &nbsp;每个操作都是原子的。</div><div>volitile的作用就是强制到主内存里去读取变量，而不是从工作区读取，从而保证多个线程间的变量可见，也就是满足线程安全的可见性。&nbsp;</div><h2>2.1 线程间的通信</h2><div>&nbsp; 线程中的同步是通过 wait() 和 notify() 来实现的。 （wait()/notify()都是object类中的方法）</div><div>&nbsp; 1.wait() 和 notify() 必须和 synchronized 配合来使用。</div><div>&nbsp; 2.wait() 释放锁,notify()不释放锁。</div><div><pre style=\"background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.0pt;\"><span style=\"color:#629755;font-style:italic;\">/**<br></span><span style=\"color:#629755;font-style:italic;\"> * wait/notify 通知<br></span><span style=\"color:#629755;font-style:italic;\"> * Created by dudy on 2017/1/25.<br></span><span style=\"color:#629755;font-style:italic;\"> */<br></span><span style=\"color:#cc7832;\">public class </span>ListAdd2 {<br><br>    <span style=\"color:#cc7832;\">public volatile static </span>List  <span style=\"color:#9876aa;font-style:italic;\">list </span>= <span style=\"color:#cc7832;\">new </span>ArrayList()<span style=\"color:#cc7832;\">;<br></span><span style=\"color:#cc7832;\"><br></span><span style=\"color:#cc7832;\">    public  void </span><span style=\"color:#ffc66d;\">add</span>(){<br>        <span style=\"color:#9876aa;font-style:italic;\">list</span>.add(<span style=\"color:#6a8759;\">\"dudy\"</span>)<span style=\"color:#cc7832;\">;<br></span><span style=\"color:#cc7832;\">    </span>}<br><br>    <span style=\"color:#cc7832;\">public  int </span><span style=\"color:#ffc66d;\">size</span>(){<br>        <span style=\"color:#cc7832;\">return  </span><span style=\"color:#9876aa;font-style:italic;\">list</span>.size()<span style=\"color:#cc7832;\">;<br></span><span style=\"color:#cc7832;\">    </span>}<br><br>    <span style=\"color:#cc7832;\">public static void </span><span style=\"color:#ffc66d;\">main</span>(String[] args) {<br>        <span style=\"color:#cc7832;\">final </span>ListAdd2  list = <span style=\"color:#cc7832;\">new </span>ListAdd2()<span style=\"color:#cc7832;\">;<br></span><span style=\"color:#cc7832;\"><br></span><span style=\"color:#cc7832;\">        final </span>Object obj = <span style=\"color:#cc7832;\">new </span>Object()<span style=\"color:#cc7832;\">;<br></span><span style=\"color:#cc7832;\"><br></span><span style=\"color:#cc7832;\">        final </span>CountDownLatch latch = <span style=\"color:#cc7832;\">new </span>CountDownLatch(<span style=\"color:#6897bb;\">1</span>)<span style=\"color:#cc7832;\">;<br></span><span style=\"color:#cc7832;\"><br></span><span style=\"color:#cc7832;\">        </span>Thread t1 = <span style=\"color:#cc7832;\">new </span>Thread(<span style=\"color:#cc7832;\">new </span>Runnable() {<br>            <span style=\"color:#cc7832;\">public void </span><span style=\"color:#ffc66d;\">run</span>() {<br>                <span style=\"color:#808080;\">//synchronized (obj) {<br></span><span style=\"color:#808080;\">                    </span><span style=\"color:#cc7832;\">for </span>(<span style=\"color:#cc7832;\">int </span>i = <span style=\"color:#6897bb;\">0</span><span style=\"color:#cc7832;\">; </span>i &lt;<span style=\"color:#6897bb;\">10</span><span style=\"color:#cc7832;\">; </span>i++) {<br>                        <span style=\"color:#b389c5;\">list</span>.add()<span style=\"color:#cc7832;\">;<br></span><span style=\"color:#cc7832;\">                        </span>System.<span style=\"color:#9876aa;font-style:italic;\">out</span>.println(<span style=\"color:#6a8759;\">\"当前线程\" </span>+ Thread.<span style=\"font-style:italic;\">currentThread</span>().getName() + <span style=\"color:#6a8759;\">\"添加了一个元素\"</span>)<span style=\"color:#cc7832;\">;<br></span><span style=\"color:#cc7832;\">                        if </span>(<span style=\"color:#b389c5;\">list</span>.size() == <span style=\"color:#6897bb;\">5</span>) {<br>                            System.<span style=\"color:#9876aa;font-style:italic;\">out</span>.println(<span style=\"color:#6a8759;\">\"当前线程发出通知：\" </span>+ Thread.<span style=\"font-style:italic;\">currentThread</span>().getName())<span style=\"color:#cc7832;\">;<br></span><span style=\"color:#cc7832;\">                           </span><span style=\"color:#808080;\">// obj.notify();<br></span><span style=\"color:#808080;\">                            </span><span style=\"color:#b389c5;\">latch</span>.countDown()<span style=\"color:#cc7832;\">;<br></span><span style=\"color:#cc7832;\">                        </span>}<br>                        <span style=\"color:#cc7832;\">try </span>{<br>                            Thread.<span style=\"font-style:italic;\">sleep</span>(<span style=\"color:#6897bb;\">1000</span>)<span style=\"color:#cc7832;\">;<br></span><span style=\"color:#cc7832;\">                        </span>} <span style=\"color:#cc7832;\">catch </span>(InterruptedException e) {<br>                            e.printStackTrace()<span style=\"color:#cc7832;\">;<br></span><span style=\"color:#cc7832;\">                        </span>}<br>                    }<br>                <span style=\"color:#808080;\">//}<br></span><span style=\"color:#808080;\">            </span>}<br>        }<span style=\"color:#cc7832;\">,</span><span style=\"color:#6a8759;\">\"t1\"</span>)<span style=\"color:#cc7832;\">;<br></span><span style=\"color:#cc7832;\"><br></span><span style=\"color:#cc7832;\"><br></span><span style=\"color:#cc7832;\">        </span>Thread t2 = <span style=\"color:#cc7832;\">new </span>Thread(<span style=\"color:#cc7832;\">new </span>Runnable() {<br>            <span style=\"color:#cc7832;\">public void </span><span style=\"color:#ffc66d;\">run</span>() {<br>            <span style=\"color:#808080;\">//synchronized (obj){<br></span><span style=\"color:#808080;\">                </span><span style=\"color:#cc7832;\">while </span>(<span style=\"color:#cc7832;\">true</span>){<br>                    <span style=\"color:#cc7832;\">if</span>(<span style=\"color:#b389c5;\">list</span>.size() != <span style=\"color:#6897bb;\">5</span>){<br>                        <span style=\"color:#cc7832;\">try </span>{<br>                            System.<span style=\"color:#9876aa;font-style:italic;\">out</span>.println(<span style=\"color:#6a8759;\">\"当前状态不符合条件，等待其他线程...\"</span>)<span style=\"color:#cc7832;\">;<br></span><span style=\"color:#cc7832;\">                            </span><span style=\"color:#808080;\">//obj.wait();<br></span><span style=\"color:#808080;\">                            </span><span style=\"color:#b389c5;\">latch</span>.await()<span style=\"color:#cc7832;\">;<br></span><span style=\"color:#cc7832;\">                            </span>System.<span style=\"color:#9876aa;font-style:italic;\">out</span>.println(<span style=\"color:#6a8759;\">\"线程接收中断:\" </span>+ Thread.<span style=\"font-style:italic;\">currentThread</span>().getName())<span style=\"color:#cc7832;\">;<br></span><span style=\"color:#cc7832;\">                            throw  new </span>RuntimeException()<span style=\"color:#cc7832;\">;<br></span><span style=\"color:#cc7832;\">                        </span>} <span style=\"color:#cc7832;\">catch </span>(InterruptedException e) {<br>                            e.printStackTrace()<span style=\"color:#cc7832;\">;<br></span><span style=\"color:#cc7832;\">                        </span>}<br><br>                    }<br>                }<br>            <span style=\"color:#808080;\">//}<br></span><span style=\"color:#808080;\"><br></span><span style=\"color:#808080;\">            </span>}<br>        }<span style=\"color:#cc7832;\">,</span><span style=\"color:#6a8759;\">\"t2\"</span>)<span style=\"color:#cc7832;\">;<br></span><span style=\"color:#cc7832;\"><br></span><span style=\"color:#cc7832;\"><br></span><span style=\"color:#cc7832;\">        </span>t2.start()<span style=\"color:#cc7832;\">;<br></span><span style=\"color:#cc7832;\">        </span>t1.start()<span style=\"color:#cc7832;\">;<br></span><span style=\"color:#cc7832;\"><br></span><span style=\"color:#cc7832;\">    </span>}<br>}<br></pre></div><div><br></div><h3>2.2 wait/notify 模拟queue</h3><h3>2.3 ThreadLocal</h3><div>ThreadLocal概念：线程局部变量，是一种多线程间并发访问变量的解决方案。与其synchronized等加锁方式不同，ThreadLocal完全不提供锁，而使用以空间换时间方式，为每个线程提供变量的独立副本，以保障线程安全。</div><div>从性能上说，ThreadLocal不具有绝对的优势，在并发不是很高的时候，加锁的性能可能更好，但作为一套与锁完全无关的线程安全解决方案，在高并发量或者竞争激烈的场景，使用ThreadLocal可以在一定程度上减少锁竞争。</div><h3>2.4多线程和单例</h3><div>double check instance&nbsp;</div><div>static &nbsp;inner class</div><div><pre style=\"background-color:#2b2b2b;color:#a9b7c6;font-family:'Menlo';font-size:9.0pt;\"><span style=\"color:#cc7832;\">public class </span>InnerSingleton {<br><br><br>    <span style=\"color:#cc7832;\">public  static class </span>Singleton {<br>        <span style=\"color:#cc7832;\">private  static  </span>Singleton <span style=\"color:#9876aa;font-style:italic;\">singleton</span>= <span style=\"color:#cc7832;\">new </span>Singleton()<span style=\"color:#cc7832;\">;<br></span><span style=\"color:#cc7832;\">    </span>}<br><br>    <span style=\"color:#cc7832;\">public  static </span>Singleton <span style=\"color:#ffc66d;\">getInstance</span>(){<br>        <span style=\"color:#cc7832;\">return </span>Singleton.<span style=\"color:#9876aa;font-style:italic;\">singleton</span><span style=\"color:#cc7832;\">;<br></span><span style=\"color:#cc7832;\">    </span>}<br>}  </pre></div><div><br></div>"
    }
  ]
}