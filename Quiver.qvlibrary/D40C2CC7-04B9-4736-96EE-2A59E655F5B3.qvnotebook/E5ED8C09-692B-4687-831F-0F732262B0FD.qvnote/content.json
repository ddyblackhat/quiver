{
  "title": "Java base",
  "cells": [
    {
      "type": "markdown",
      "data": "---\r\ntitle: 开发基础\r\n---\r\n\r\n## 数据结构\r\n### 数组\r\n数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。如果应用需要快速访问数据，很少或不插入和删除元素，就应该用数组，** 数组作用就是申请内存**，redis和memcache等内存数据库内部其实就是申请了个很大的内存。\r\n\r\n* 无序数组可以提供快速的插入，但查找和删除较慢。\r\n* 有序数组可以使用二分查找。二分查找需要的时间与数组中数据项的个数的对数成正比。\r\n<!-- more -->\r\n### 链表\r\n链表与数组在底层实现上恰好相反，链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起。\r\n![](http://7xpyf5.com1.z0.glb.clouddn.com/linklist.png)\r\n单链表:\r\nNode结构:\r\n①指向下个节点的“指针”(node 对象)\r\n②节点数据。\r\n③对于尾节点next 指向null\r\n\r\n双向链表:不只是有一个first,还要有一个last,主要使用场景就是可以倒序遍历。\r\n\r\n单向链表简单结构:\r\n\r\n```java\r\n//http://blog.csdn.net/tayanxunhua/article/details/11100097\r\npublic class LinkList<T> {\r\n\r\n\t// 节点信息\r\n\tclass Node<T> {\r\n\t\tprotected Node<T> next;\r\n\t\tprotected T data;\r\n\r\n\t\tpublic void display() {\r\n\t\t\tSystem.out.println(data);\r\n\t\t}\r\n\r\n\t\tpublic Node(T data) {\r\n\t\t\tthis.data = data;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tprivate Node<T> header;\r\n\r\n\tpublic LinkList() {\r\n\t\tthis.header = null;\r\n\t}\r\n\r\n\tpublic void addFirst(T data) { // 插入到头节点中\r\n\t\tNode<T> node = new Node<T>(data); // 创建新的节点\r\n\t\tnode.next = header; // 新节点的 next --> header, header 变为下一个节点\r\n\r\n\t\tthis.header = node; // header --> node , node 变为头节点\r\n\t\t//header.display();\r\n\r\n\t}\r\n\r\n\tpublic void displayAllNode() {\r\n\t\tNode<T> current = header;\r\n\t\twhile (current != null) {\r\n\t\t\tcurrent.display();\r\n\t\t\tcurrent = current.next; // 当前节点指向下一个节点\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tLinkList<Integer> link1 = new LinkList<Integer>();\r\n\t\tlink1.addFirst(1);\r\n\t\tlink1.addFirst(2);\r\n\t\tlink1.addFirst(3);\r\n\t\tlink1.displayAllNode();\r\n\t}\r\n}\r\n\r\n```\r\n### 树\r\n是由n(n>=1)个节点组成的具有层次结构的集合。因为样子像一颗树倒挂而得名。\r\n#### 二叉树(每个节点的子树最多有两个)：\r\n深度为K的二叉树至多有2^k-1个节点\r\n完全二叉树:除最后一层最后未满的二叉树\r\n满二叉树:除最后一层全为叶子节点外，所有节点均为两个子节点。\r\n\r\n\r\n```java\r\n\r\npublic class BinTree {\r\n\t// TreeNode 节点结构\r\n\tclass TreeNode{\r\n\t\tprotected int value;\r\n\t\tprotected TreeNode leftChild;\r\n\t\tprotected TreeNode rightChild;\r\n\t\tpublic TreeNode(int value) {\r\n\t\t\tthis.value = value;\r\n\t\t}\r\n\t}\r\n\tprivate TreeNode root;\r\n\r\n\tpublic BinTree(int data) {\r\n\t\tTreeNode treeNode = new TreeNode(data);\r\n\t\tthis.root = treeNode;\r\n\t}\r\n\t\r\n\tpublic static void main(String[] args) {\r\n\t\tBinTree tree1 = new BinTree(1);\r\n\t    tree1.init();\r\n\t    tree1.display(tree1.root);\r\n\t}\r\n\t//前序遍历\r\n\tprivate void display(TreeNode root) {\r\n\t\t// TODO Auto-generated method stub\r\n\t\tSystem.out.println(root.value);\r\n\t\tif( root.leftChild != null){\r\n\t\t\tdisplay(root.leftChild);\r\n\t\t}\r\n\t\tif( root.rightChild != null){\r\n\t\t\tdisplay(root.rightChild);\r\n\t\t}\r\n\t}\r\n    /*\r\n     *        1\r\n     *    2       3 \r\n     *  4   5   \r\n     */\r\n\tprivate  void init() {\r\n\t\tTreeNode ltree1 = new TreeNode(2);\r\n\t\tTreeNode ltree2 = new TreeNode(4);\r\n\t\tTreeNode rtree1 = new TreeNode(3);\r\n\t\tTreeNode rtree2 = new TreeNode(5);\r\n\t\tthis.root.leftChild = ltree1;\r\n\t\tthis.root.rightChild = rtree1;\r\n\t\tltree1.leftChild = ltree2;\r\n\t\tltree1.rightChild = rtree2;\r\n\t}\r\n}\r\n\r\n```\r\n### 递归\r\n递归是一种方法调用自己的编程技术。通常可以把一个大型的复杂问题转化为一个与原问题相似的规模较小的问题来求解。\r\n\r\n优点:代码简洁、清晰，并且容易验证正确性。\r\n缺点:它的运行需要较多次数的函数调用，如果调用层次比较深，需要增加额外的堆栈处理,可能出现堆栈溢出的情况。\r\n\r\n一般设计三部分:\r\n边界条件\r\n递归前进段: 边界条件不满足时，递归前进。\r\n递归返回段: 边界条件满足时，递归返回。\r\n\r\n很多地方都体现递归的思想,比如二叉树遍历。\r\n主要的两个思想: \r\n**分而治之**\r\n**递归**\r\n---\r\n## 算法\r\n### 算法的时间复杂度\r\n算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。复杂度越大，算法执行效率越低。\r\n#### 计算方法:\r\n一般简单的计算方法是:\r\n看看有几重循环，一重时间复杂度为O（n）,二重则为O（n^2）,以此类推，如果有二分则为O（logn），如果是一个for循环套一个二分，那么时间复杂度为O（nlogn）\r\n#### 查找算法基础\r\n顺序查找:无序存储结构最方便的查找方法，时间复杂度为O(n);\r\n折半查找法:在按顺序存储的数据结构中，每次取出中间位置的数据与目标数据比较。比如:二分法查找。\r\n时间复杂度为O(logN)。\r\n\r\n![](http://7xpyf5.com1.z0.glb.clouddn.com/TimeSpace.png)\r\n#### 基础排序算法\r\n* 选择排序:首先从要排序的数组中选出最大（最小）的与第一个位置交换，然后再从剩下的数组中选择（最大）最小与第二个位置进行交换，直至到最后一个元素。\r\n* 插入排序：基本思想是将数插入到一个<u>有序</u>的队列中，第一次把第一个数当作有序队列将第二个数插入，第二次将前两个数当作有序队列，插入第三个数，直至最后一个元素插入完毕。\r\n* 冒泡排序:让大数往下沉，小数往上走，如果<u>相邻</u>的两个元素不符合排序顺序就交换。每一趟可以让一个元素到达最终位置。\r\n* 快速排序:\r\n基本思想: 1. 选择一个基准，将要排序的数组分成两组，比基准数都小的一组，比基准数都大的一组。\r\n2.调用自身对左边的一组进行排序。\r\n3.调用自身对右边的一组进行排序。\r\n![](http://7xpyf5.com1.z0.glb.clouddn.com/quick01.png) <br>\r\n其实这也是递归的思想。基本的递归的快速排序算法的代码相当简单。另一个是基准值的位置:怎么才能把这个基准值移动到正确位置上来呢？\r\n![](http://7xpyf5.com1.z0.glb.clouddn.com/quick02.png)\r\n\r\n**只要交换基准值和右边子数组的最左端的数据项就可以了。**\r\n\r\n* 归并排序:\r\n基本思想是将两个（或两个以上）有序表合并成一个新的有序表。即把一个无序的表分割成若干个有序的子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。\r\n![](http://7xpyf5.com1.z0.glb.clouddn.com/guibing.png)\r\n\r\n---\r\n## java内存特性之内存管理\r\n1.显示内存管理和自动内存管理\r\n>  显示内存管理（C/C++）\r\n  内存管理是程序开发者的职责\r\n  显示管理常见问题:①野指针②内存泄露。\r\n\r\n2.自动内存管理(java/c#/一些脚本语言)\r\n>  垃圾回收器程序自动管理。\r\n  优点:增加了程序的可靠性，减小了内存泄露和野指针的情况，提高了开发人员的效率。\r\n  缺点:GC时间无法控制;逻辑上的内存泄露依然会存在;系统需要花费时间进行内存回收，增加了软件负担。\r\n\r\n### java内存模型\r\n\r\n参看:[Java虚拟机的内存组成以及堆内存介绍](http://www.hollischuang.com/archives/80)\r\n\r\n![](http://www.hollischuang.com/wp-content/uploads/2015/04/2838681554.jpg)\r\n\r\n**Young(年轻代)**\r\n1.分为Eden区和两个Survivor区（大小一致，有些地方称为from区和to区）\r\n2.新的对象实例总是先放到Eden区，Survior区作为Eden区和Tenure区的缓冲，可以向Tenure区转移对象\r\n<br>\r\n**Tenured(终身代)**\r\n存放生命周期长久的实例对象，但是对象依然也会被回收掉\r\n<br>\r\n**Perm(永久代)**\r\n主要存放加载的Class类级对象如class本身，method,field等等。\r\njava8永久代去掉了,增加了一个元空间Metaspace。\r\n\r\n  \r\n### 常见的GC算法\r\nGC机制一般做两个事情:发现无用信息对象；回收被无用对象占用的内存空间，使该空间可被程序再次使用。\r\nGC算法:\r\n* **引用计数法**：使用引用计数器来区分存活对象和不再使用对象。引用计数器为0时即满足被回收的时机。客观来说判定效率很高，但是无法解决对象循环引用的问题。<br>\r\n* **标记-清除算法（Mark-Sweep）**：使用了根集的概念。从根基开始扫描，识别出哪些对象可达，哪些对象不可达，不可达的即可以被回收。在扫描识别过程中，基于tracing算法的垃圾收集也称为标记和清除(mark-and-sweep)垃圾收集器。最大的问题是回收后的空间不连续，对于内存分配，不连续的内存空间的工作效率要低于连续的空间。</br>\r\n* **copying算法**：为了解决内存空间碎片的问题，复制算法开始时把堆分成两块。程序从空闲面对象分配空间，当对象满了，基于coping算法的垃圾 收集就从根集中扫描活动对象，并将每个 活动对象复制到空闲面。一般内存中新生代的From区和To区就作为两个这两个对象块。从Survior区经过GC存活的对象可能移动到另一个Survivor区或者移动到老年代当中.</br>\r\n* **adaptive算法**:特性的情况下，不同的GC算法会有不同效率。基于Adaptive算法的垃圾收集器就是监控当前堆的使用情况，并将选择适当算法的垃圾收集器。\r\n\r\n### 四中引用类型:\r\n* Strong Reference(强引用)\r\n会尽可能长时间的存活于JVM内，只有当没有任何对象指向它时GC执行后才会被回收。\r\neg:StrongReference sr = new StrongReference(new A());（存储）\r\nA a  = (A)sr.get(); (取出)\r\n* WeakReference & WeakHashMap(弱引用)\r\nWeakReference:当所引用的对象不再有强引用时，weakreference会被GC回收,作用是引用一个对象，但是并不阻止该对象被回收。\r\n弱引用最常见的用处在于解决强引用所带来的对象之间的存活时间上的耦合关系。\r\nWeakHashMap:使用WeakReference作为key，一旦没有指向key的强引用，GC会自动删除相关的value\r\n* SoftReference\r\n与WeakReference的区别是尽可能最长时间保留引用直到JVM内存不足才会被回收，这一特性使得SoftRefrence非常适合于设计缓存。\r\n* PhantomReference(虚引用)\r\n与其他所有引用都不同，它并不会决定对象的声明周期。虚引用主要用来跟踪对象被垃圾回收器回收的活动。与软引用和若引用的一个区别在于必须与引用队列联合使用。垃圾回收器回收时，如果发现它还有虚引用，就会在回收对象之前把这个虚引用加入到与之关联的引用队列中。\r\n参看:[Java之美[从菜鸟到高手演变]之JVM内存管理及垃圾回收](http://blog.csdn.net/zhangerqing/article/details/8214365)\r\n\r\n"
    }
  ]
}