{
  "title": "动态代理",
  "cells": [
    {
      "type": "markdown",
      "data": "title: 动态代理，Spring Aop类似实现\r\n### 动态代理\r\n一种设计模式，为其他对象提供一种代理以控制对这个对象的访问。\r\n<!--more -->\r\n```java\r\npackage com.ddyblackhat.javase.proxy;\r\n\r\nimport java.lang.reflect.InvocationHandler;\r\nimport java.lang.reflect.Method;\r\nimport java.lang.reflect.Proxy;\r\n\r\ninterface Subject {// 抽象类\r\n\tpublic void doSomething();\r\n}\r\n\r\ninterface Say {\r\n\tpublic void saySomething();\r\n}\r\n\r\nclass RealSubject implements Subject, Say {// 实现类\r\n\r\n\t@Override\r\n\tpublic void doSomething() {\r\n\t\tSystem.out.println(\"call doSomething()\");\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void saySomething() {\r\n\t\t// TODO Auto-generated method stub\r\n\t\tSystem.out.println(\"say something\");\r\n\t}\r\n\r\n}\r\n\r\n// class SubjectProxy implements Subject{// 静态代理\r\n//\r\n// Subject subimpl = new RealSubject();\r\n// @Override\r\n// public void doSomething() {\r\n// subimpl.doSomething();\r\n// }\r\n// @Override\r\n// public void saySomething() {\r\n// // TODO Auto-generated method stub\r\n//\r\n// }\r\n//\r\n// }\r\n\r\nclass ProxyHandler { // 动态代理\r\n\tprivate Object tar; // 要代理的对象\r\n\r\n\tpublic ProxyHandler(Object tar) {\r\n\t\tthis.tar = tar;\r\n\t}\r\n\r\n\tpublic Object getProxy() {\r\n\t\tif (tar == null)\r\n\t\t\tthrow new RuntimeException(\"tar is null\");\r\n\r\n\t\t// 1. 准备目标对象的类加载器\r\n\t\t// ①获取目标对象的Class类对象\r\n\t\tClass<? extends Object> tarClass = this.tar.getClass();\r\n\t\t// ②获取类加载器对象\r\n\t\tClassLoader loader = tarClass.getClassLoader();\r\n\r\n\t\t// 2. 准备目标对象所实现的接口类型的数组\r\n\t\tClass<?>[] interfaces = tarClass.getInterfaces();\r\n\r\n\t\t// 3. 准备InvocationHandler对象\r\n\t\t InvocationHandler h = new InvocationHandler() {\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n\t\t\t\t// TODO Auto-generated method stub\r\n\t\t\t\tString className = tar.getClass().getName();\r\n\t\t\t\tString methodName = method.getName();\r\n\t\t\t\tObject result = null;\r\n\t\t\t\ttry {\r\n\t\t\t\t\tSystem.out.println(\"[日志][\" + className + \"]\" + methodName + \"开始...\");\r\n\t\t\t\t\tresult = method.invoke(tar, args);\r\n\t\t\t\t\tSystem.out.println(\"[日志][\" + className + \"]\" + methodName + \"正常结束...\");\r\n\t\t\t\t} catch (Exception e) {\r\n\t\t\t\t\t// TODO Auto-generated catch block\r\n\t\t\t\t\tSystem.out.println(\"[日志][\" + className + \"]\" + methodName + \"异常结束...\");\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t} finally {\r\n\t\t\t\t\tSystem.out.println(\"[日志][\" + className + \"]\" + methodName + \"最终结束...\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn result;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tObject o = Proxy.newProxyInstance(loader, interfaces, h);\r\n\t\treturn o;\r\n\t}\r\n\r\n}\r\n\r\npublic class ProxyTest {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\t// Subject sub = new SubjectProxy();\r\n\t\t// sub.doSomething();\r\n\r\n\t\tProxyHandler proxy = new ProxyHandler(new RealSubject());\r\n\t\tSubject rs = (Subject) proxy.getProxy();\r\n\t\tSay say = (Say) proxy.getProxy();\r\n\r\n\t\trs.doSomething();\r\n\t\tsay.saySomething();\r\n\t}\r\n}\r\n\r\n\r\n```\r\n输出：\r\n```java\r\n[日志][com.ddyblackhat.javase.proxy.RealSubject]doSomething开始...\r\ncall doSomething()\r\n[日志][com.ddyblackhat.javase.proxy.RealSubject]doSomething正常结束...\r\n[日志][com.ddyblackhat.javase.proxy.RealSubject]doSomething最终结束...\r\n[日志][com.ddyblackhat.javase.proxy.RealSubject]saySomething开始...\r\nsay something\r\n[日志][com.ddyblackhat.javase.proxy.RealSubject]saySomething正常结束...\r\n[日志][com.ddyblackhat.javase.proxy.RealSubject]saySomething最终结束...\r\n```\r\n#### 使用java自带的动态代理实现，\r\n* 实现InvocationHandler 接口创建自己的调用处理器。\r\n* 通过Proxy.newProxyInstance创建代理类。需要传入3个参数。\r\n * classloader \r\n * interfaces \r\n * invocationHandler 对象。\r\n\r\n#### 代理角色\r\n* 抽象角色：声明真实对象和代理对象的共同接口，这样一来在任何使用目标对象的地方都可以使用代理对象。\r\n* 代理角色：代理对象内部含有目标对象的引用，从而可以在任何时候操作对象；代理对象提供一个与目标对象相同的接口，以便可以在任何时候替代目标对象。代理对象通常在客户端调动传递给目标对象之前或之后，执行某个操作，而不是单纯地将调用传递给目标对象，同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象的封装。\r\n* 真实角色：著作权归作者所有。定义了代理对象所代表的目标对象，代理角色所代表的真实对象，是我们最终要引用的对象,定义了代理对象所代表的目标对象。\r\n#### 动态代理的作用\r\n1. Proxy类的代码量被固定下来，不会因为业务的逐渐庞大而庞大\r\n2. 可以实现AOP编程，实际上静态代理也可以实现，AOP可以算作是代理模式的一个典型应用\r\n3. 解耦,通过参数就可以判断真实类，不需要事先实例化，更加灵活多变。\r\n\r\n#### 拓展\r\n1. 可以使用Properties属性文件配置要代理的类。\r\n2. 目标方法的前后动态的插入方法，而不是单一功能。（这个可以怎么实现？）\r\n\r\n\r\n"
    }
  ]
}