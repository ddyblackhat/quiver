{
  "title": "java并发（二）",
  "cells": [
    {
      "type": "text",
      "data": "<h2>4 并发类容器</h2><div>jdk1.5以后提供了多种并发类容器来替换同步类容器从而改善性能。同步类容器的状态都是串行化的，严重降低了并发性，在多线程环境时，严重降低了应用程序的吞吐量。</div><div>并发类容器是专门针对并发设计的，使用<b><font color=\"#323232\" style=\"background-color: rgb(254, 250, 0);\">ConcurrentHashMap来代替给予散列的传统的HashTable</font></b>,而且在ConcurrentHashMap中添加了一些常见复合操作的支持。以及使用了<font color=\"#323232\" style=\"background-color: rgb(254, 250, 0);\">CopyOnWriteArrayList代替Voctor</font>，并发的CopyOnWriteArraySet,以及并发的Queue，ConcurrentLinkedQueue和LinkedBlockingQueue，前者是高性能的队列，后者是以阻塞形式的队列。</div><div><br></div><h3>4.1ConcurrentMap</h3><div>ConcurrentMap接口下有两个重要的实现：</div><div>&nbsp; ConcurrentHashMap</div><div>&nbsp; ConcurrentSkipListMap（支持并发排序功能，弥补ConcurrentHashMap）</div><div>ConcurrentHashMap 内部使用段（Segment）来表示这些不同的部分，每个段其实就是一个小的HashTable，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。把一个整体分成16个段（Segment），也就是最高支持16个线程的并发修改操作。这也是在多线程场景时减少锁的粒度从而降低锁竞争的一种方案。并且代码中大多共享变量使用volitile关键字声明，目的是第一时间获取修改的内容，性能非常好。</div><h3>4.2 Copy-On-Write容器</h3><div>Copy-On-Write简称Cow，是一种用于程序设计中的优化策略。</div><div>JDK里的COW容器有两种：CopyOnWriteArrayList 和 CopyOnWriteArraySet。</div><div><br></div><div>CopyOnWrite容器即写时复制的容器。好处就是对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前不会添加任务元素。</div><div>CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</div><div><br></div><h2>5.1 并发Queue</h2><div>在并发队列上jdk提供了两套实现，一个是以<font color=\"#323232\" style=\"background-color: rgb(254, 250, 0);\">ConcurrentLinkedQueue</font>为代表的高性能队列，一个是以<font color=\"#323232\" style=\"background-color: rgb(254, 250, 0);\">BlockingQueue</font>接口为代表的阻塞队列，无论哪种队列都继承自Queue</div><h3>5.2 ConcurrentLinkedQueue</h3><div>是一个适用于高并发场景下的队列，通过无锁的方式，实现了高并发状态下的高性能，通常ConcurrentLinkedQueue性能好于BlockingQueue。它是一个基于链接节点的无解线程安全队列。该队列不允许null元素。</div><div>重要方法：</div><div>&nbsp; add() 和 offer() 都是加入元素的方法（在ConcurrentLinkedQueue中，这两没有区别）</div><div>&nbsp; poll() 和peek() 都是取出头节点，区别在于前者会删除元素，后者不会。</div><h3>5.3 BlockingQueue接口</h3><div>ArrayBlockingQueue：基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，其内部并没有实现读写分离，也就意味着生产和消费不能完全并行，长度是需要定义的，可以指定先进先出或者先进后出，也叫有界队列。</div><div>LinkedBlockingQueue：基于链表的阻塞队列，通ArrayBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），LinkedBlockingQueue之所以能高效的处理并发数据，是因为其内部实现采用分离锁（读写分离），从而实现生产者和消费者操作的完全并行运行。他是一个无界队列。</div><div>SynchronousQueue：一种没有缓冲的队列，生产者产生的数据直接回被消费者获取并消费。</div><div>PriorityBlockingQueue:基于优先级的阻塞队列(优先级的判断通过构造函数传入的Compator对象来决定，必须实现Comparable接口)，内部控制线程同步的锁采用的是公平锁，他也是一个无界队列。</div><div>DelayQueue：带有延迟时间的Queue,其中的元素只有当其指定的延迟时间到了，才能够从队列中获取该元素。DelayQueue中的元素必须实现Delayed接口，DelayQueue是一个没有大小限制的队列，应用场景很多，比如对缓存超时的数据进行移除、任务超时处理、空闲连接的关闭等等。</div><div><br></div><h2>6 多线程的设计模式</h2><div>并行计算模式属于设计优化的一部分，它是对一些常用的多线程结构的总结和抽象。与串行程序相比，并行程序结构通常更为复杂。因此合理的使用并行模式在多线程开发中更具有意义。Future、Master-Worker和生产者-消费者模型。</div><h3>6.2 future模式</h3><div><img src=\"quiver-image-url/817319628F19CA2AF8808E92F3067380.png\" alt=\"屏幕快照 2017-02-04 19.44.20.png\"><br></div><h3>6.3 Master-Worker模式</h3><div>Master-Worker模式是 常用的并行计算模式。它的核心思想是系统由两类进程协作工作：Master进程和Worker进程。Master进程负责接收和分配任务，Worker负责处理字任务。当各个Worker子进程处理完成后，会将结果返回给Master，由Master做归纳和总结。其好处是能将一个大任务分解成若干个小任务，并行执行，从而提高系统的吞吐量。</div><div><img src=\"quiver-image-url/2D0B67A6F73C69AA360910707EA10F0D.png\" alt=\"屏幕快照 2017-02-04 19.23.40.png\"><br></div>"
    }
  ]
}